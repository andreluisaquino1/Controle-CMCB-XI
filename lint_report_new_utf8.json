[{"filePath":"D:\\Projetos\\CMCB-XI\\src\\hooks\\use-pix-batch.ts","messages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":37,"column":13,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":37,"endColumn":42,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[932,961],"text":"// @ts-expect-error - RPC not typed"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":40,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1124,1127],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1124,1127],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":67,"column":13,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":67,"endColumn":42,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[2110,2139],"text":"// @ts-expect-error - RPC not typed"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\r\nimport { supabase } from \"@/integrations/supabase/client\";\r\nimport { toast } from \"sonner\";\r\nimport { useAuth } from \"@/contexts/AuthContext\";\r\n\r\nexport interface PixFeeItem {\r\n    amount: number;\r\n    description: string;\r\n    occurred_at?: string;\r\n}\r\n\r\nexport interface PixFeeBatchPayload {\r\n    items: PixFeeItem[];\r\n    reference?: string;\r\n    occurred_at?: string;\r\n}\r\n\r\nexport interface TransactionItem {\r\n    id: string;\r\n    amount: number;\r\n    description: string | null;\r\n    occurred_at: string | null;\r\n    created_at: string;\r\n}\r\n\r\nexport function useCreatePixFeeBatch() {\r\n    const queryClient = useQueryClient();\r\n\r\n    return useMutation({\r\n        mutationFn: async ({\r\n            entityId,\r\n            payload,\r\n        }: {\r\n            entityId: string;\r\n            payload: PixFeeBatchPayload;\r\n        }) => {\r\n            // @ts-ignore - RPC not typed\r\n            const { data, error } = await supabase.rpc(\"process_pix_fee_batch\", {\r\n                p_entity_id: entityId,\r\n                p_payload: payload as any,\r\n            });\r\n\r\n            if (error) throw error;\r\n            return data;\r\n        },\r\n        onSettled: () => {\r\n            queryClient.invalidateQueries({ queryKey: [\"dashboard-data\"] });\r\n            queryClient.invalidateQueries({ queryKey: [\"accounts\"] });\r\n            queryClient.invalidateQueries({ queryKey: [\"transactions\"] });\r\n            queryClient.invalidateQueries({ queryKey: [\"all-transactions\"] });\r\n            toast.success(\"Taxas PIX lan├ºadas com sucesso!\");\r\n        },\r\n        onError: (error: Error) => {\r\n            console.error(\"Pix Batch error:\", error);\r\n            toast.error(error.message || \"Erro ao lan├ºar taxas.\");\r\n        },\r\n    });\r\n}\r\n\r\nexport function useTransactionItems(parentTransactionId: string | null) {\r\n    const { user } = useAuth();\r\n\r\n    return useQuery({\r\n        queryKey: [\"transaction-items\", parentTransactionId],\r\n        queryFn: async () => {\r\n            if (!parentTransactionId) return [];\r\n            // @ts-ignore - RPC not typed\r\n            const { data, error } = await supabase.rpc(\"get_transaction_items\", {\r\n                p_parent_transaction_id: parentTransactionId,\r\n            });\r\n\r\n            if (error) throw error;\r\n            return data as TransactionItem[];\r\n        },\r\n        enabled: !!parentTransactionId && !!user,\r\n    });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\Projetos\\CMCB-XI\\src\\hooks\\use-transactions.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":59,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2326,2329],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2326,2329],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":200,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":200,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9141,9144],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9141,9144],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useMutation, useQueryClient } from \"@tanstack/react-query\";\r\nimport { supabase } from \"@/integrations/supabase/client\";\r\nimport { useAuth } from \"@/contexts/AuthContext\";\r\nimport { toast } from \"sonner\";\r\nimport { Account, DashboardData, Merchant } from \"@/types\";\r\nimport { ACCOUNT_NAMES } from \"@/lib/constants\";\r\nimport { Database } from \"@/integrations/supabase/types\";\r\nimport { useDemoData } from \"@/demo/useDemoData\";\r\n\r\ntype TransactionModule = Database[\"public\"][\"Enums\"][\"transaction_module\"];\r\n\r\ninterface CreateTransactionData {\r\n  transaction_date: string;\r\n  module: TransactionModule;\r\n  entity_id?: string | null;\r\n  source_account_id?: string | null;\r\n  destination_account_id?: string | null;\r\n  merchant_id?: string | null;\r\n  amount: number;\r\n  direction: \"in\" | \"out\" | \"transfer\";\r\n  payment_method?: \"cash\" | \"pix\" | null;\r\n  origin_fund?: \"UE\" | \"CX\" | null;\r\n  capital_custeio?: \"capital\" | \"custeio\" | null;\r\n  shift?: \"matutino\" | \"vespertino\" | null;\r\n  description?: string | null;\r\n  notes?: string | null;\r\n  parent_transaction_id?: string | null;\r\n}\r\n\r\nexport function useCreateTransaction() {\r\n  const { user, isDemo } = useAuth();\r\n  const queryClient = useQueryClient();\r\n  const { addTransaction } = useDemoData();\r\n\r\n  return useMutation({\r\n    mutationFn: async ({\r\n      transaction,\r\n    }: {\r\n      transaction: CreateTransactionData;\r\n    }) => {\r\n      if (!user) throw new Error(\"Usu├írio n├úo autenticado\");\r\n\r\n      if (isDemo) {\r\n        const mockTx = {\r\n          id: crypto.randomUUID(),\r\n          date: transaction.transaction_date,\r\n          description: transaction.description || 'Lan├ºamento Demo',\r\n          amount: transaction.amount,\r\n          type: transaction.direction === 'in' ? 'income' : 'expense',\r\n          category: transaction.module,\r\n          account_id: transaction.destination_account_id || transaction.source_account_id || '',\r\n          merchant_id: transaction.merchant_id || undefined,\r\n          source_account_id: transaction.source_account_id || undefined,\r\n          destination_account_id: transaction.destination_account_id || undefined,\r\n          module: transaction.module\r\n        };\r\n        // @ts-expect-error - mockTx is compatible for demo purposes\r\n        addTransaction(mockTx);\r\n        return mockTx as Record<string, any>;\r\n      }\r\n\r\n      const { data: txn, error: txnError } = await supabase\r\n        .rpc(\"process_transaction\", {\r\n          p_tx: {\r\n            transaction_date: transaction.transaction_date,\r\n            module: transaction.module,\r\n            entity_id: transaction.entity_id || null,\r\n            source_account_id: transaction.source_account_id || null,\r\n            destination_account_id: transaction.destination_account_id || null,\r\n            merchant_id: transaction.merchant_id || null,\r\n            amount: transaction.amount,\r\n            direction: transaction.direction,\r\n            payment_method: transaction.payment_method || null,\r\n            origin_fund: transaction.origin_fund || null,\r\n            capital_custeio: transaction.capital_custeio || null,\r\n            shift: transaction.shift || null,\r\n            description: transaction.description || null,\r\n            notes: transaction.notes || null,\r\n            parent_transaction_id: transaction.parent_transaction_id || null,\r\n          }\r\n        })\r\n        .single();\r\n\r\n      if (txnError) throw txnError;\r\n      return txn;\r\n    },\r\n    onMutate: async ({ transaction }) => {\r\n      await queryClient.cancelQueries({ queryKey: [\"dashboard-data\"] });\r\n      await queryClient.cancelQueries({ queryKey: [\"accounts\"] });\r\n      await queryClient.cancelQueries({ queryKey: [\"merchants\"] });\r\n\r\n      const previousDashboard = queryClient.getQueryData<DashboardData>([\"dashboard-data\"]);\r\n      const previousAccounts = queryClient.getQueryData<Account[]>([\"accounts\"]);\r\n      const previousMerchants = queryClient.getQueryData<Merchant[]>([\"merchants\"]);\r\n\r\n      if (previousDashboard) {\r\n        const newDashboard = { ...previousDashboard };\r\n        const amount = Number(transaction.amount);\r\n\r\n        // Generic balance adjustment based on direction and account name\r\n        if (transaction.direction === \"in\" || transaction.direction === \"out\") {\r\n          const isAdd = transaction.direction === \"in\";\r\n          const accId = isAdd ? transaction.destination_account_id : transaction.source_account_id;\r\n\r\n          if (accId && previousAccounts) {\r\n            const acc = previousAccounts.find(a => a.id === accId);\r\n            if (acc) {\r\n              if (acc.name === ACCOUNT_NAMES.ESPECIE) newDashboard.especieBalance += (isAdd ? amount : -amount);\r\n              else if (acc.name === ACCOUNT_NAMES.PIX) newDashboard.pixBalance += (isAdd ? amount : -amount);\r\n              else if (acc.name === ACCOUNT_NAMES.COFRE) newDashboard.cofreBalance += (isAdd ? amount : -amount);\r\n              else if (acc.name === ACCOUNT_NAMES.CONTA_DIGITAL) newDashboard.contaDigitalBalance += (isAdd ? amount : -amount);\r\n            }\r\n          }\r\n        }\r\n\r\n        if (transaction.direction === \"transfer\" && transaction.source_account_id && transaction.destination_account_id) {\r\n          const srcAcc = previousAccounts?.find(a => a.id === transaction.source_account_id);\r\n          const dstAcc = previousAccounts?.find(a => a.id === transaction.destination_account_id);\r\n\r\n          if (srcAcc) {\r\n            if (srcAcc.name === ACCOUNT_NAMES.ESPECIE) newDashboard.especieBalance -= amount;\r\n            else if (srcAcc.name === ACCOUNT_NAMES.PIX) newDashboard.pixBalance -= amount;\r\n            else if (srcAcc.name === ACCOUNT_NAMES.COFRE) newDashboard.cofreBalance -= amount;\r\n            else if (srcAcc.name === ACCOUNT_NAMES.CONTA_DIGITAL) newDashboard.contaDigitalBalance -= amount;\r\n          }\r\n          if (dstAcc) {\r\n            if (dstAcc.name === ACCOUNT_NAMES.ESPECIE) newDashboard.especieBalance += amount;\r\n            else if (dstAcc.name === ACCOUNT_NAMES.PIX) newDashboard.pixBalance += amount;\r\n            else if (dstAcc.name === ACCOUNT_NAMES.COFRE) newDashboard.cofreBalance += amount;\r\n            else if (dstAcc.name === ACCOUNT_NAMES.CONTA_DIGITAL) newDashboard.contaDigitalBalance += amount;\r\n          }\r\n        }\r\n\r\n        if (transaction.merchant_id) {\r\n          const mIdx = newDashboard.merchantBalances.findIndex(m => m.id === transaction.merchant_id);\r\n          if (mIdx !== -1) {\r\n            const m = { ...newDashboard.merchantBalances[mIdx] };\r\n            if (transaction.module === \"aporte_saldo\" || transaction.module === \"aporte_estabelecimento_recurso\") {\r\n              m.balance += amount;\r\n            } else if (transaction.module === \"consumo_saldo\") {\r\n              m.balance -= amount;\r\n            }\r\n            newDashboard.merchantBalances[mIdx] = m;\r\n          }\r\n        }\r\n\r\n        queryClient.setQueryData([\"dashboard-data\"], newDashboard);\r\n      }\r\n\r\n      if (previousAccounts) {\r\n        const newAccounts = previousAccounts.map(acc => {\r\n          const amount = Number(transaction.amount);\r\n          let newBalance = acc.balance;\r\n\r\n          if (transaction.direction === \"transfer\") {\r\n            if (acc.id === transaction.source_account_id) newBalance -= amount;\r\n            if (acc.id === transaction.destination_account_id) newBalance += amount;\r\n          } else if (transaction.direction === \"in\" && acc.id === transaction.destination_account_id) {\r\n            newBalance += amount;\r\n          } else if (transaction.direction === \"out\" && acc.id === transaction.source_account_id) {\r\n            newBalance -= amount;\r\n          }\r\n\r\n          return { ...acc, balance: newBalance };\r\n        });\r\n        queryClient.setQueryData([\"accounts\"], newAccounts);\r\n      }\r\n\r\n      return { previousDashboard, previousAccounts, previousMerchants };\r\n    },\r\n    onError: (error: Error, __, context) => {\r\n      console.error(\"Transaction error:\", error);\r\n      if (context) {\r\n        queryClient.setQueryData([\"dashboard-data\"], context.previousDashboard);\r\n        queryClient.setQueryData([\"accounts\"], context.previousAccounts);\r\n        queryClient.setQueryData([\"merchants\"], context.previousMerchants);\r\n      }\r\n      toast.error(error.message || \"N├úo foi poss├¡vel registrar a opera├º├úo.\");\r\n    },\r\n    onSettled: () => {\r\n      queryClient.invalidateQueries({ queryKey: [\"dashboard-data\"] });\r\n      queryClient.invalidateQueries({ queryKey: [\"accounts\"] });\r\n      queryClient.invalidateQueries({ queryKey: [\"merchants\"] });\r\n      queryClient.invalidateQueries({ queryKey: [\"transactions\"] });\r\n      queryClient.invalidateQueries({ queryKey: [\"entities-with-accounts\"] });\r\n      queryClient.invalidateQueries({ queryKey: [\"all-transactions\"] });\r\n      queryClient.invalidateQueries({ queryKey: [\"saldos-transactions\"] });\r\n      queryClient.invalidateQueries({ queryKey: [\"recursos-transactions\"] });\r\n    },\r\n  });\r\n}\r\n\r\nexport function useCreateResourceTransaction() {\r\n  const queryClient = useQueryClient();\r\n\r\n  return useMutation({\r\n    mutationFn: async ({\r\n      transaction,\r\n    }: {\r\n      transaction: any;\r\n    }) => {\r\n      const { data: txn, error: txnError } = await supabase\r\n        .rpc(\"process_resource_transaction\", {\r\n          p_tx: transaction\r\n        })\r\n        .single();\r\n\r\n      if (txnError) throw txnError;\r\n      return txn;\r\n    },\r\n    onSettled: () => {\r\n      queryClient.invalidateQueries({ queryKey: [\"dashboard-data\"] });\r\n      queryClient.invalidateQueries({ queryKey: [\"accounts\"] });\r\n      queryClient.invalidateQueries({ queryKey: [\"merchants\"] });\r\n      queryClient.invalidateQueries({ queryKey: [\"transactions\"] });\r\n      queryClient.invalidateQueries({ queryKey: [\"entities-with-accounts\"] });\r\n      queryClient.invalidateQueries({ queryKey: [\"all-transactions\"] });\r\n      queryClient.invalidateQueries({ queryKey: [\"saldos-transactions\"] });\r\n      queryClient.invalidateQueries({ queryKey: [\"recursos-transactions\"] });\r\n    },\r\n    onError: (error: Error) => {\r\n      console.error(\"Resource Transaction error:\", error);\r\n      toast.error(error.message || \"N├úo foi poss├¡vel registrar a opera├º├úo de recurso.\");\r\n    },\r\n  });\r\n}\r\n\r\nexport function useVoidTransaction() {\r\n  const { user } = useAuth();\r\n  const queryClient = useQueryClient();\r\n\r\n  return useMutation({\r\n    mutationFn: async ({\r\n      transactionId,\r\n      reason,\r\n    }: {\r\n      transactionId: string;\r\n      reason: string;\r\n    }) => {\r\n      const { data, error } = await supabase.rpc(\"void_transaction\", {\r\n        p_id: transactionId,\r\n        p_reason: reason,\r\n      });\r\n\r\n      if (error) throw error;\r\n      return data;\r\n    },\r\n    onError: (error: Error) => {\r\n      console.error(\"Void error:\", error);\r\n      toast.error(error.message || \"N├úo foi poss├¡vel anular a transa├º├úo.\");\r\n    },\r\n    onSettled: () => {\r\n      queryClient.invalidateQueries({ queryKey: [\"dashboard-data\"] });\r\n      queryClient.invalidateQueries({ queryKey: [\"accounts\"] });\r\n      queryClient.invalidateQueries({ queryKey: [\"merchants\"] });\r\n      queryClient.invalidateQueries({ queryKey: [\"transactions\"] });\r\n      queryClient.invalidateQueries({ queryKey: [\"entities-with-accounts\"] });\r\n      queryClient.invalidateQueries({ queryKey: [\"all-transactions\"] });\r\n      queryClient.invalidateQueries({ queryKey: [\"saldos-transactions\"] });\r\n      queryClient.invalidateQueries({ queryKey: [\"recursos-transactions\"] });\r\n      toast.success(\"A transa├º├úo foi anulada com sucesso.\");\r\n    },\r\n  });\r\n}\r\n","usedDeprecatedRules":[]}]
